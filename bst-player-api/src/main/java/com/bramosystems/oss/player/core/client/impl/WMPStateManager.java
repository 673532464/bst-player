/*
 * Copyright 2009 Sikirulai Braheem
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.bramosystems.oss.player.core.client.impl;

import com.bramosystems.oss.player.core.event.client.PlayerStateEvent;
import com.bramosystems.oss.player.core.event.client.HasMediaStateHandlers;
import com.bramosystems.oss.player.core.event.client.PlayStateEvent;
import com.bramosystems.oss.player.core.event.client.MediaInfoEvent;
import com.bramosystems.oss.player.core.event.client.LoadingProgressEvent;
import com.bramosystems.oss.player.core.event.client.DebugEvent;
import com.bramosystems.oss.player.core.client.MediaInfo;
import com.google.gwt.user.client.Timer;
import java.util.HashMap;
import java.util.Iterator;

/**
 * This class handles the events generated by the embedded Windows Media Player.
 * It maps the WMP states into the corresponding event in the API.
 *
 * @author Sikirulai Braheem
 */
public class WMPStateManager {

    protected HashMap<String, StateManager> cache;

    WMPStateManager() {
        cache = new HashMap<String, StateManager>();
        initGlobalEventListeners(this);
    }

    public void init(WinMediaPlayerImpl player, HasMediaStateHandlers handler, boolean resizing) {
        StateManager sm = new StateManager(player, handler, resizing);
        cache.put(player.getPlayerId(), sm);
        sm.checkPlayState();
    }

    /**
     * Provided for deferred binding enhancements. Resize fix required for
     * non-IE browsers only
     *
     * @return
     */
    public boolean shouldRunResizeQuickFix() {
        return true;
    }

    public final boolean isPlayerStateManaged(String playerId) {
        return cache.containsKey(playerId);
    }

    public void close(String playerId) {
        cache.remove(playerId);
    }

    public void stop(String playerId) {
        // do nothing, workaround for webkit implementation...
    }

    @SuppressWarnings("unused")
    private void firePlayStateChanged() {
        Iterator<String> keys = cache.keySet().iterator();
        while (keys.hasNext()) {
            cache.get(keys.next()).checkPlayState();
        }
    }

    @SuppressWarnings("unused")
    private void fireError() {
        Iterator<String> keys = cache.keySet().iterator();
        while (keys.hasNext()) {
            String id = keys.next();
            cache.get(id).checkError();
        }
    }

    @SuppressWarnings("unused")
    private void fireBuffering(boolean buffering) {
        Iterator<String> keys = cache.keySet().iterator();
        while (keys.hasNext()) {
            cache.get(keys.next()).doBuffering(buffering);
        }
    }

    protected native void initGlobalEventListeners(WMPStateManager impl) /*-{
    $wnd.OnDSPlayStateChangeEvt = function(NewState) {
    impl.@com.bramosystems.oss.player.core.client.impl.WMPStateManager::firePlayStateChanged()();
    }
    $wnd.OnDSErrorEvt = function() {
    impl.@com.bramosystems.oss.player.core.client.impl.WMPStateManager::fireError()();
    }
    $wnd.OnDSBufferingEvt = function(Start) {
    impl.@com.bramosystems.oss.player.core.client.impl.WMPStateManager::fireBuffering(Z)(Start);
    }
    }-*/;

    public void registerMediaStateHandlers(WinMediaPlayerImpl player) {
        // do nothing, provided for DOM event registration in IE.
    }

    protected class StateManager {

        protected HasMediaStateHandlers handlers;
        protected boolean canDoMetadata,  playerInitd,  resizing;
        private Timer downloadProgressTimer;
        protected WinMediaPlayerImpl player;

        public StateManager(final WinMediaPlayerImpl _player,
                HasMediaStateHandlers _handlers, boolean _resizing) {
            this.handlers = _handlers;
            this.player = _player;
            this.resizing = _resizing;
            canDoMetadata = false;
            playerInitd = false;
            downloadProgressTimer = new Timer() {

                @Override
                public void run() {
                    LoadingProgressEvent.fire(handlers, player.getDownloadProgress());
                }
            };
        }

        public void checkPlayState() {
            int state = player.getPlayState();
            if (state < 0) {
                return;
            }

            processPlayState(state);
        }

        public void onError(String message) {
            DebugEvent.fire(handlers, DebugEvent.MessageType.Error, message);
        }

        public void debug(String msg) {
            DebugEvent.fire(handlers, DebugEvent.MessageType.Info, msg);
        }

        public void doBuffering(boolean buffering) {
            PlayerStateEvent.fire(handlers,
                    buffering ? PlayerStateEvent.State.BufferingStarted : PlayerStateEvent.State.BufferingFinished);

            debug("Buffering " + (buffering ? " started" : " stopped"));
            if (buffering) {
                downloadProgressTimer.scheduleRepeating(1000);
            } else {
                downloadProgressTimer.cancel();
                LoadingProgressEvent.fire(handlers, 1.0);
                debug("Media loading complete");
            }
        }

        public void processPlayState(int state) {
            switch (state) {
                case 1:    // stopped..
                    debug("Media playback stopped");
                    PlayStateEvent.fire(handlers, PlayStateEvent.State.Stopped, 0);
                    break;
                case 2:    // paused..
                    debug("Media playback paused");
                    PlayStateEvent.fire(handlers, PlayStateEvent.State.Paused, 0);
                    break;
                case 3:    // playing..
                    PlayStateEvent.fire(handlers, PlayStateEvent.State.Started, 0);
                    doMetadata();        // do metadata ...
                    break;
                case 8:    // media ended...
                    PlayStateEvent.fire(handlers, PlayStateEvent.State.Finished, 0);
                    debug("Media playback finished");

                    // TODO: disable subsequent metadata (for playlist) until better resizing method
                    // is found for firefox brothers...
                    // resizing = false;
                    break;
                case 10:    // player ready...
                    PlayerStateEvent.fire(handlers, PlayerStateEvent.State.Ready);
                    if (!playerInitd && !resizing) {
                        debug("Windows Media Player plugin");
                        debug("Version : " + player.getPlayerVersion());
                        playerInitd = true;
                    }
                    break;
                case 6:    // buffering ...
                case 11:    // reconnecting to stream  ...
                    break;
                case 9:     // preparing new item ...
                    canDoMetadata = true;
            }
        }

        public void checkError() {
            onError(player.getErrorDiscription());
        }

        protected void doMetadata() {
            if (resizing) {      // don't raise metadata event again, we've gotten it before;
                return;         // we're just resizing...
            }

            if (!canDoMetadata) {
                debug("Media playback resumed");
                return;
            }
            debug("Playing media at " + player.getURL());

            MediaInfo info = new MediaInfo();
            String err = "";
            player.fillMetadata(info, err);
            if (err.length() == 0) {
                canDoMetadata = false;
                MediaInfoEvent.fire(handlers, info);
            } else {
                onError(err);
            }
        }
    }
}
